#! /usr/bin/env python2
#coding=UTF-8
from __future__ import print_function

# python2-webvi requirements >=
# python2-pycurl
# python2-libxslt1
# python2-libxml2
#
# Run uninstalled webvi as
# PYTHONPATH=src/libwebvi python2 src/webvicli/webvi --templatepath=templates

# Dependencies:
# python2
# python2-qt4
# python2-webvi
# QT or Freedesktop icon theme?

# TODO
# Investigate timeouts (keeps retrying when gateway removed)

fromlist = ("traced", "trace", "tracer")
ftrace = __import__("ftrace", fromlist=fromlist)
for name in fromlist:
    setattr(__builtins__, name, getattr(ftrace, name))

import webvi.api as webvi
from webvi.constants import (
    WebviRequestType, WebviOpt, WebviConfig, WebviSelectBitmask, WebviSelect
)
from PyQt4.QtGui import (
    QApplication,
    QTreeWidget, QTreeWidgetItem,
    QMainWindow, QAction, QLabel, QIcon, QFont, QHeaderView, QStyle
)
from PyQt4.QtCore import (Qt, QTimer, QSocketNotifier)
import event
from contextlib import closing
import xml.etree.cElementTree as etree
from lib import Record
from sys import (stderr, argv)
from functools import partial
from sys import (excepthook, exc_info)

def trace_coro(coro, *args, **kw):
    print(coro.__name__, args, kw, end=" ", file=stderr)
    stderr.flush()
    ret = (yield coro(*args, **kw))
    print("->", repr(ret), file=stderr)
    raise StopIteration(ret)

def main():
    (opt, _) = webvi.load_config()
    webvi.apply_config(opt)
    
    app = QApplication([])
    
    w = Window(
        windowTitle="Webvi",
    )
    
    with closing(event.Group()) as w.coros:
        event.Routine(w.main(*argv[1:]), w.coros)
        app.exec_()

class Window(QMainWindow):
    def __init__(self, *args, **kw):
        QMainWindow.__init__(self, *args, **kw)
        
        m = self.menuBar().addMenu("Dessert&s")
        #~ m.addAction(QAction("Refresh menu", self))
        #~ m.addAction(QAction("Go to . . .", self))
        #~ m.addAction(QAction("Copy menu URI", self))
        #~ m.addAction(QAction("Copy stream URL", self))
        #~ m.addAction(QAction("Play", self))
        #~ m.addAction(QAction("Download", self))
        m.addAction(QAction("E&xit", self,
            menuRole=QAction.QuitRole,
            triggered=self.close,
        ))
        
        self.tree = QTreeWidget(
            selectionMode=QTreeWidget.ExtendedSelection,
            contextMenuPolicy=Qt.ActionsContextMenu,
            itemExpanded=self.size_tree,
            itemCollapsed=self.size_tree,
            expandsOnDoubleClick=False,
            verticalScrollMode=QTreeWidget.ScrollPerPixel,
            headerHidden=True,
        )
        self.tree.itemExpanded.connect(self.item_expanded)
        
        self.setCentralWidget(self.tree)
        
        self.show()
        
        self.wv_finished = dict()
        self.wv_timer = QTimer(
            singleShot=True,
            timeout=partial(self.wv_action,
                WebviSelect.TIMEOUT, WebviSelectBitmask.CHECK),
        )
        webvi.set_config(WebviConfig.TIMEOUT_CALLBACK, self.set_wv_timeout)
        self.wv_notes = list()
    
    def item_expanded(self, item):
        data = item.data(0, Qt.UserRole).toPyObject()
        if data.opened:
            return
        data.opened = True
        
        event.Routine(self.menu(item), self.coros)
    
    def main(self, ref="wvt:///?srcurl=mainmenu"):
        root = self.tree.invisibleRootItem()
        root.setData(0, Qt.UserRole, Record(ref=ref))
        return self.menu(root)
    
    def menu(self, parent):
        handle = trace(webvi.new_request,
            parent.data(0, Qt.UserRole).toPyObject().ref,
            WebviRequestType.MENU)
        if handle == -1:
            raise Exception("Failed to open handle")
        
        webvi.set_opt(handle, WebviOpt.WRITEFUNC, buffer_write)
        
        buffer = bytearray()
        webvi.set_opt(handle, WebviOpt.WRITEDATA, buffer)
        
        finished = event.Queue()
        self.wv_finished[handle] = finished
        
        webvi.start_handle(handle)
        self.reschedule_wv()
        yield finished.get()
        
        trace(webvi.delete_handle, handle)
        
        parent.takeChildren()
        
        root = etree.XML(str(buffer))
        if root.tag != "wvmenu":
            raise Exception("Expected <wvmenu> root element")
        
        #~ queryitems = []
        #~ menupage = menu.Menu()
        for node in root:
            if node.tag == "title":
                title = node.text
                if title:
                    item = QTreeWidgetItem(parent, (title,))
                    item.setIcon(0, QApplication.style().standardIcon(
                        QStyle.SP_ArrowForward))
                    font = item.font(0)
                    font.setBold(True)
                    item.setFont(0, font)
            
            elif node.tag == "link":
                label = node.find("label")
                if label is None:
                    label = ""
                else:
                    label = label.text
                item = QTreeWidgetItem(parent, (label,))
                
                data = Record(opened=False)
                item.setData(0, Qt.UserRole, data)
                
                item_ref = node.find("ref")
                if item_ref is not None:
                    data.ref = item_ref.text
                    QTreeWidgetItem(item, (". . .",)).setDisabled(True)
                
                stream = node.find("stream")
                if stream is not None:
                    data.stream = stream.text
                    item.setIcon(0, QApplication.style().standardIcon(
                        QStyle.SP_FileIcon))
                    font = item.font(0)
                    font.setFamily("serif")
                    font.setItalic(True)
                    item.setFont(0, font)
                    print(label, data.stream, file=stderr)
            
            #~ elif node.tag == 'textfield':
                #~ menuitem = self.parse_textfield(node)
                #~ menupage.add(menuitem)
                #~ queryitems.append(menuitem)
            #~ elif node.name == 'itemlist':
                #~ menuitem = self.parse_itemlist(node)
                #~ menupage.add(menuitem)
                #~ queryitems.append(menuitem)
            
            elif node.tag == 'textarea':
                # TODO: word wrap
                QTreeWidgetItem(parent, (node.find("label").text,))
            
            #~ elif node.name == 'button':
                #~ menuitem = self.parse_button(node, queryitems)
                #~ menupage.add(menuitem)
            
            else:
                etree.dump(node)
        self.size_tree()
        return
    
    @traced
    def set_wv_timeout(self, timeout, _):
        if timeout < 0:
            self.wv_timer.stop()
        else:
            self.wv_timer.start(timeout)
    
    def reschedule_wv(self):
        while self.wv_notes:
            self.wv_notes.pop().setEnabled(False)
        
        while True:
            (finished, status, errmsg, remaining) = webvi.pop_message()
            if finished != -1:
                finished = self.wv_finished.pop(finished)
                if status:
                    finished.put(exc=EnvironmentError(status, errmsg))
                else:
                    finished.put()
            if status not in (-1, 0):
                raise EnvironmentError(status, errmsg)
            if not remaining:
                break
        
        (_, read, write, exc, _) = webvi.fdset()
        for (name, type, bitmask) in (
            ("read", QSocketNotifier.Read, WebviSelectBitmask.READ),
            ("write", QSocketNotifier.Write, WebviSelectBitmask.WRITE),
            ("exc", QSocketNotifier.Exception, WebviSelectBitmask.EXCEPTION),
        ):
            action = partial(self.wv_action, bitmask=bitmask)
            for fd in locals()[name]:
                note = QSocketNotifier(fd, type, activated=action)
                note.setEnabled(True)
                self.wv_notes.append(note)
        
        if not self.wv_timer.isActive():
            self.wv_timer.start(10 * 1000)
    
    def wv_action(self, fd, bitmask):
        webvi.perform(fd, bitmask)
        self.reschedule_wv()
    
    def size_tree(self):
        self.tree.resizeColumnToContents(0)

@partial(traced, abbrev=set((0, "data")))
def buffer_write(data, len, buffer):
    buffer.extend(data)
    return len

if "__main__" == __name__:
    from gc import (set_debug, DEBUG_LEAK, collect, garbage)
    set_debug(DEBUG_LEAK)
    
    try:
        main()
    finally:
        collect()
        # Cannot help that class definitions create garbage cycles
        ignore = [g for g in garbage if isinstance(g, type)]
        del garbage[:]
        collect()
        if garbage:
            try:
                import cycles
                cycles.show()
            except Exception:
                excepthook(*exc_info())
            
            print(len(garbage), file=stderr)
            for g in garbage:
                print(repr(g), file=stderr)
